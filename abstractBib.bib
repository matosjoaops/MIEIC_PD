@inproceedings{henkelDatasetDockerfiles2020,
  title = {A {{Dataset}} of {{Dockerfiles}}},
  booktitle = {Proceedings of the 17th {{International Conference}} on {{Mining Software Repositories}}},
  author = {Henkel, Jordan and Bird, Christian and Lahiri, Shuvendu K. and Reps, Thomas},
  year = {2020},
  month = sep,
  series = {{{MSR}} '20},
  pages = {528--532},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/3379597.3387498},
  abstract = {Dockerfiles are one of the most prevalent kinds of DevOps artifacts used in industry. Despite their prevalence, there is a lack of sophisticated semantics-aware static analysis of Dockerfiles. In this paper, we introduce a dataset of approximately 178,000 unique Dockerfiles collected from GitHub. To enhance the usability of this data, we describe five representations we have devised for working with, mining from, and analyzing these Dockerfiles. Each Dockerfile representation builds upon the previous ones, and the final representation, created by three levels of nested parsing and abstraction, makes tasks such as mining and static checking tractable. The Dockerfiles, in each of the five representations, along with metadata and the tools used to shepard the data from one representation to the next are all available at: https://doi.org/10.5281/zenodo.3628771.},
  isbn = {978-1-4503-7517-7},
  keywords = {Bash; Mining,Datasets,DevOps,Docker},
  file = {/home/mechjm/Zotero/storage/C7V6MEHW/Henkel et al_2020_A Dataset of Dockerfiles.pdf}
}

@inproceedings{henkelShipwrightHumanintheLoopSystem2021,
  title = {Shipwright: {{A Human-in-the-Loop System}} for {{Dockerfile Repair}}},
  shorttitle = {Shipwright},
  booktitle = {2021 {{IEEE}}/{{ACM}} 43rd {{International Conference}} on {{Software Engineering}} ({{ICSE}})},
  author = {Henkel, Jordan and Silva, Denini and Teixeira, Leopoldo and {d'Amorim}, Marcelo and Reps, Thomas},
  year = {2021},
  month = may,
  pages = {1148--1160},
  issn = {1558-1225},
  doi = {10.1109/ICSE43902.2021.00106},
  abstract = {Docker is a tool for lightweight OS-level virtualization. Docker images are created by performing a build, controlled by a source-level artifact called a Dockerfile. We studied Dockerfiles on GitHub, and-to our great surprise-found that over a quarter of the examined Dockerfiles failed to build (and thus to produce images). To address this problem, we propose SHIPWRIGHT, a human-in-the-loop system for finding repairs to broken Dockerfiles. SHIPWRIGHT uses a modified version of the BERT language model to embed build logs and to cluster broken Dockerfiles. Using these clusters and a search-based procedure, we were able to design 13 rules for making automated repairs to Dockerfiles. With the aid of SHIPWRIGHT, we submitted 45 pull requests (with a 42.2\% acceptance rate) to GitHub projects with broken Dockerfiles. Furthermore, in a "time-travel" analysis of broken Dockerfiles that were later fixed, we found that SHIPWRIGHT proposed repairs that were equivalent to human-authored patches in 22.77\% of the cases we studied. Finally, we compared our work with recent, state-of-the-art, static Dockerfile analyses, and found that, while static tools detected possible build-failure-inducing issues in 20.6-33.8\% of the files we examined, SHIPWRIGHT was able to detect possible issues in 73.25\% of the files and, additionally, provide automated repairs for 18.9\% of the files.},
  keywords = {Bit error rate,DevOps,Docker,Maintenance engineering,Repair,Software development management,Software engineering,Tools,Virtualization},
  file = {/home/mechjm/Zotero/storage/J8GW4ADJ/Henkel et al_2021_Shipwright.pdf;/home/mechjm/Zotero/storage/W3DRMDCN/9402069.html}
}

@misc{InvestigatingInnerWorkings,
  title = {Investigating the Inner Workings of Container Image Vulnerability Scanners},
  howpublished = {https://oda.oslomet.no/oda-xmlui/bitstream/handle/11250/3017416/zarei-acit2022.pdf?sequence=1},
  file = {/home/mechjm/Zotero/storage/GL7KWTXY/zarei-acit2022.pdf}
}

@article{linnalampiOutdatedSoftwareContainer,
  title = {Outdated Software in Container Images},
  author = {Linnalampi, Markus},
  pages = {57},
  abstract = {In recent years, containers have become a central part of modern software development. Containers enable faster development cycle, better reproducibility and are ideal for modern microservice architectures. Docker has become the de facto standard of containers, but recently OCI has made most of the containers compatible and provider independent. As containers have become more essential, their security has become a major concern. Containers have significantly different technical implementation than the old virtualized servers. Because of this, the old best practices are not always relevant anymore with the new technology. Containers have a completely new security environment, which offers both new ways of improving the security of software, but also creates new problems. This is why understanding the container security has become essential. First, this thesis discusses the history of containers, the reasons why containers have become popular in recent years as well as the technical background of containers. After that, the most essential best practices for container security and the reasoning behind them is discussed. The actual research topic of this thesis is solutions to detecting outdated software versions from container images. The thesis discusses the most popular existing tools for this and shows results for most popular container images. After that, the limitations of existing tools is discussed, a new approach for the problem is proposed and the new method and existing tools are compared.},
  langid = {english},
  file = {/home/mechjm/Zotero/storage/G8QLN34J/Linnalampi - Outdated software in container images.pdf}
}

@article{maduroAutomaticServiceContainerization2021,
  title = {Automatic {{Service Containerization}} with {{Docker}}},
  author = {Maduro, Jo{\~a}o Carlos Cardoso},
  year = {2021},
  month = jul,
  copyright = {openAccess},
  langid = {english},
  annotation = {Accepted: 2022-09-07T17:51:15Z},
  file = {/home/mechjm/Zotero/storage/5KBGRUIW/Maduro_2021_Automatic Service Containerization with Docker.pdf;/home/mechjm/Zotero/storage/LFW4JMAP/135486.html}
}

@article{mcardleContainerImageOptimisation2016,
  title = {Container {{Image Optimisation}} and {{Security Practices}}},
  shorttitle = {{{THE DUBLIN DASHBOARD}}},
  author = {McArdle, G. and Kitchin, R.},
  year = {2016},
  month = sep,
  journal = {ISPRS Annals of the Photogrammetry, Remote Sensing and Spatial Information Sciences},
  volume = {IV-4/W1},
  pages = {19--25},
  issn = {2194-9050},
  doi = {10.5194/isprs-annals-IV-4-W1-19-2016},
  abstract = {Cloud Computing is one of the major developments that offers a promising future. One of the basic tools which makes the Cloud a reality is virtualization. Hypervisor-based virtualization comes with high performance and overhead performance due to the added level of abstraction. Virtual Machine results in high service downtime whenever the application is updated to the new version. Containers have various advantages over virtual machines due to performance enhancements and reduced start time. Docker is widely used in the business environment and at the personal level container environment. If the Docker image has been stored locally on the server, Docker technology can frequently reduce the launch time from a few minutes to less than 5 seconds. However, these container images are very customisable and are typically created at runtime by executing script instructions from a remote base image (the Docker file). Many input files, including the packages and dependencies, may need to be acquired from the Internet during the execution of the instruction. The process of creating an image can be time-consuming and iterative.},
  langid = {english},
  file = {/home/mechjm/Zotero/storage/2RYN6ELE/McArdle e Kitchin - 2016 - THE DUBLIN DASHBOARD DESIGN AND DEVELOPMENT OF A .pdf}
}

@article{mcmillanMAKINGCONTAINERSEASIER,
  title = {{{MAKING CONTAINERS EASIER WITH HPC CONTAINER MAKER}}},
  author = {McMillan, Scott},
  pages = {47},
  langid = {english},
  file = {/home/mechjm/Zotero/storage/8AVZTJ7C/McMillan - MAKING CONTAINERS EASIER WITH HPC CONTAINER MAKER.pdf}
}

@article{prinettoSecurityMisconfigurationsDetection,
  title = {Security {{Misconfigurations Detection}} and {{Repair}} in {{Dockerfile}}},
  author = {Prinetto, Paolo Ernesto and Bortolameotti, Dott Riccardo and Massaro, Giuseppe},
  pages = {78},
  langid = {english},
  file = {/home/mechjm/Zotero/storage/YUGFDRWA/Prinetto et al. - Security Misconfigurations Detection and Repair in.pdf}
}

@inproceedings{reisDockerliveLiveDevelopment2022,
  title = {Dockerlive : {{A}} Live Development Environment for {{Dockerfiles}}},
  shorttitle = {Dockerlive},
  booktitle = {2022 {{IEEE Symposium}} on {{Visual Languages}} and {{Human-Centric Computing}} ({{VL}}/{{HCC}})},
  author = {Reis, David and Correia, Filipe F.},
  year = {2022},
  month = sep,
  pages = {1--4},
  publisher = {{IEEE}},
  address = {{Roma, Italy}},
  doi = {10.1109/VL/HCC53370.2022.9833145},
  abstract = {The process of developing Dockerfiles is perceived by many developers as slow and based on trial-and-error, and it is hardly immediate to see the result of a change introduced into a Dockerfile. In this work we propose a plugin for Visual Studio Code, which we name Dockerlive, and that has the purpose of shortening the length of feedback loops. Namely, the plugin is capable of providing information to developers on a number of Dockerfile elements, as the developer is writing the Dockerfile. We achieve this through dynamic analysis of the resulting container, which the plugin builds and runs in the background.},
  isbn = {978-1-66544-214-5},
  langid = {english},
  file = {/home/mechjm/Zotero/storage/FUMSBADG/Reis e Correia - 2022 - Dockerlive  A live development environment for Do.pdf}
}

@article{reisLiveDockerContainers2020,
  title = {Live {{Docker Containers}}},
  author = {Reis, David Alexandre Gomes},
  year = {2020},
  month = jul,
  abstract = {The use of containerization technologies for software development, such as Docker, is now widespread, with over 70000 Dockerfiles being found in projects from the GitHub platform as of October 2016. The use of these technologies has a few advantages, providing a secure, portable and efficient environment where applications can be executed. Currently, the usual workflow of a developer configuring a Docker environment consists of writing a Dockerfile, building the Dockerfile into a Docker image, instantiating that Docker image in a Docker container and verifying if the container is working as expected (using a tool or the command-line). If the container is not behaving as expected, then the developer has to make changes to the Dockerfile and repeat the process, until the desired behaviour is achieved. This process is often slow, based on trial-and-error, and therefore time consuming and frustrating for developers, as observed in a survey performed with students with some Docker experience. As such, reducing the temporal distance between editing a Dockerfile and observing the consequences of those changes on the containers that can be built from that Dockerfile (i.e. tightening the feedback loop) can reduce the debugging efforts required by the programmer.  Live programming refers to the ability to obtain continuous feedback on a program while that program is being developed. Since software is usually developed on text editors/IDEs, live feedback is usually provided within these tools. The level of liveness in IDEs is related to the type and update frequency of the feedback provided. The existing tools that can help a developer working with Dockerfiles can be split into several categories: container status, performance monitoring, container management, infrastructure testing, static analysis and image build optimization. However, currently the only tools which provide live feedback are some static analysis tools. Therefore, the developer is restricted to the development workflow mentioned above, with little liveness in his environment. Providing more live dynamic feedback in the developer's environment is expected to lead to an increased efficiency of developers working on Dockerfiles. This can be achieved through the implementation of an IDE plugin which automatically builds, instantiates and extracts information from a Docker container while the developer writes the respective Dockerfile, providing continuous feedback on changes that the developer makes. In order to quantify the influence of providing more live dynamic feedback on the efficiency of developers, a user study was conducted.},
  copyright = {openAccess},
  langid = {english},
  annotation = {Accepted: 2022-09-16T05:32:27Z},
  file = {/home/mechjm/Zotero/storage/G7BD6WNM/Reis - 2020 - Live Docker Containers.pdf;/home/mechjm/Zotero/storage/JHC85ELK/128956.html}
}

@misc{rosaFixingDockerfileSmells2022,
  title = {Fixing {{Dockerfile Smells}}: {{An Empirical Study}}},
  shorttitle = {Fixing {{Dockerfile Smells}}},
  author = {Rosa, Giovanni and Scalabrino, Simone and Oliveto, Rocco},
  year = {2022},
  month = aug,
  number = {arXiv:2208.09097},
  eprint = {2208.09097},
  eprinttype = {arxiv},
  primaryclass = {cs},
  publisher = {{arXiv}},
  abstract = {Background. Containerization technologies are widely adopted in the DevOps workflow. The most commonly used one is Docker, which requires developers to define a specification file (Dockerfile) to build the image used for creating containers. There are several best practice rules for writing Dockerfiles, but the developers do not always follow them. Violations of such practices, known as Dockerfile smells, can negatively impact the reliability and the performance of Docker images. Previous studies showed that Dockerfile smells are widely diffused, and there is a lack of automatic tools that support developers in fixing them. However, it is still unclear what Dockerfile smells get fixed by developers and to what extent developers would be willing to fix smells in the first place.},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {Computer Science - Software Engineering},
  file = {/home/mechjm/Zotero/storage/7FR8HPZ4/Rosa et al. - 2022 - Fixing Dockerfile Smells An Empirical Study.pdf}
}

@inproceedings{santoroWaleDockerfileBasedApproach2018,
  title = {Wale: {{A Dockerfile-Based Approach}} to {{Deduplicate Shared Libraries}} in {{Docker Containers}}},
  shorttitle = {Wale},
  booktitle = {2018 {{IEEE}} 16th {{Intl Conf}} on {{Dependable}}, {{Autonomic}} and {{Secure Computing}}, 16th {{Intl Conf}} on {{Pervasive Intelligence}} and {{Computing}}, 4th {{Intl Conf}} on {{Big Data Intelligence}} and {{Computing}} and {{Cyber Science}} and {{Technology Congress}}({{DASC}}/{{PiCom}}/{{DataCom}}/{{CyberSciTech}})},
  author = {Santoro, Corrado and Messina, Fabrizio and D'Urso, Fabio and Santoro, Federico Fausto},
  year = {2018},
  month = aug,
  pages = {785--791},
  doi = {10.1109/DASC/PiCom/DataCom/CyberSciTec.2018.00135},
  abstract = {This paper presents a simple, novel approach to deduplicate disk space needed by shared application libraries in Docker containers. The described approach relies on the deployment of a single Docker image called "core-image", designed to collect all the libraries shared among the various Docker images. The management of the Docker images is made by means of the automatic manipulation of the related Dockerfile, i.e. the text files which describe the composition of Docker images. The user is asked to enrich its own Dockerfiles with a number of directives, as Dockerfile comments, that represent the meta-data needed to identify the common libraries among Docker images. In this way, common libraries and files are moved into the core-image, which is rebuilt again along with the new image containers. The latter will contain only libraries and files that are not shared. The paper includes the description of a simple but realistic case study which proves the effectiveness of the approach in terms of saved disk space.},
  keywords = {Buildings,Cloud computing,Cloud Computing,Container,Containers,Docker,File system,Libraries,Virtual machine monitors,Virtual machining,Virtualization},
  file = {/home/mechjm/Zotero/storage/52ZF866M/Santoro et al_2018_Wale.pdf;/home/mechjm/Zotero/storage/UDE4ETIP/stamp.html}
}

@article{sorgallaApplyingModelDrivenEngineering2021,
  title = {Applying {{Model-Driven Engineering}} to {{Stimulate}} the {{Adoption}} of {{DevOps Processes}} in {{Small}} and {{Medium-Sized Development Organizations}}: {{The Case}} for {{Microservice Architecture}}},
  shorttitle = {Applying {{Model-Driven Engineering}} to {{Stimulate}} the {{Adoption}} of {{DevOps Processes}} in {{Small}} and {{Medium-Sized Development Organizations}}},
  author = {Sorgalla, Jonas and Wizenty, Philip and Rademacher, Florian and Sachweh, Sabine and Z{\"u}ndorf, Albert},
  year = {2021},
  month = nov,
  journal = {SN Computer Science},
  volume = {2},
  number = {6},
  pages = {459},
  issn = {2662-995X, 2661-8907},
  doi = {10.1007/s42979-021-00825-z},
  abstract = {Microservice architecture (MSA) denotes an increasingly popular architectural style in which business capabilities are wrapped into autonomously developable and deployable software components called microservices. Microservice applications are developed by multiple DevOps teams each owning one or more services. In this article, we explore the state of how DevOps teams in small and medium-sized organizations (SMOs) cope with MSA and how they can be supported. We show through a secondary analysis of an exploratory interview study comprising six cases, that the organizational and technological complexity resulting from MSA poses particular challenges for small and medium-sized organizations (SMOs). We apply model-driven engineering to address these challenges. As results of the second analysis, we identify the challenge areas of building and maintaining a common architectural understanding, and dealing with deployment technologies. To support DevOps teams of SMOs in coping with these challenges, we present a model-driven workflow based on LEMMA\textemdash the Language Ecosystem for Modeling Microservice Architecture. To implement the workflow, we extend LEMMA with the functionality to (i) generate models from API documentation; (ii) reference remote models owned by other teams; (iii) generate deployment specifications; and (iv) generate a visual representation of the overall architecture. We validate the model-driven workflow and our extensions to LEMMA through a case study showing that the added functionality to LEMMA can bring efficiency gains for DevOps teams. To develop best practices for applying our workflow to maximize efficiency in SMOs, we plan to conduct more empirical research in the field in the future.},
  langid = {english},
  file = {/home/mechjm/Zotero/storage/CI7XYTIQ/Sorgalla et al. - 2021 - Applying Model-Driven Engineering to Stimulate the.pdf}
}

@article{tomyModusDatalogDialect2022,
  title = {Modus: {{A Datalog Dialect}} for {{Building Container Images}}},
  author = {Tomy, Chris and Wang, Tingmao and Barr, Earl T and Mechtaev, Sergey},
  year = {2022},
  pages = {12},
  abstract = {Containers help share and deploy software by packaging it with all its dependencies. Tools, like Docker or Kubernetes, spawn containers from images as specified by a build system's language, such as Dockerfile. A build system takes many parameters to build an image, including OS and application versions. These build parameters can interact: setting one can restrict another. Dockerfile lacks support for reifying and constraining these interactions, thus forcing developers to write a build script per workflow. As a result, developers have resorted to creating ad hoc solutions such as templates or domain-specific frameworks that harm performance and complicate maintenance because they are verbose and mix languages.},
  langid = {english},
  file = {/home/mechjm/Zotero/storage/X2EKGXCV/Tomy et al. - 2022 - Modus A Datalog Dialect for Building Container Im.pdf}
}

@inproceedings{wuEmpiricalStudyBuild2020,
  title = {An {{Empirical Study}} of {{Build Failures}} in the {{Docker Context}}},
  booktitle = {Proceedings of the 17th {{International Conference}} on {{Mining Software Repositories}}},
  author = {Wu, Yiwen and Zhang, Yang and Wang, Tao and Wang, Huaimin},
  year = {2020},
  month = jun,
  pages = {76--80},
  publisher = {{ACM}},
  address = {{Seoul Republic of Korea}},
  doi = {10.1145/3379597.3387483},
  abstract = {Docker containers have become the de-facto industry standard. Docker builds often break, and a large amount of efforts are put into troubleshooting broken builds. Prior studies have evaluated the rate at which builds in large organizations fail. However, little is known about the frequency and fix effort of failures that occur in Docker builds of open-source projects. This paper provides a first attempt to present a preliminary study on 857,086 Docker builds from 3,828 open-source projects hosted on GitHub. Using the Docker build data, we measure the frequency of broken builds and report their fix time. Furthermore, we explore the evolution of Docker build failures across time. Our findings help to characterize and understand Docker build failures and motivate the need for collecting more empirical evidence.},
  isbn = {978-1-4503-7517-7},
  langid = {english},
  file = {/home/mechjm/Zotero/storage/QWM5CMDG/Wu et al. - 2020 - An Empirical Study of Build Failures in the Docker.pdf}
}

@inproceedings{yeDockerGenKnowledgeGraph2021a,
  title = {{{DockerGen}}: {{A Knowledge Graph}} Based {{Approach}} for {{Software Containerization}}},
  shorttitle = {{{DockerGen}}},
  booktitle = {2021 {{IEEE}} 45th {{Annual Computers}}, {{Software}}, and {{Applications Conference}} ({{COMPSAC}})},
  author = {Ye, Hongjie and Zhou, Jiahong and Chen, Wei and Zhu, Jiaxin and Wu, Guoquan and Wei, Jun},
  year = {2021},
  month = jul,
  pages = {986--991},
  issn = {0730-3157},
  doi = {10.1109/COMPSAC51774.2021.00133},
  abstract = {Docker is the de-facto container technology for software system deployment and delivery. A Dockerfile specifies how to containerize a system into a Docker image. However, creating a Dockerfile is not trivial since resolving the dependencies (e.g., third-party libraries) of diverse software requires comprehensive domain knowledge. In this paper, we propose DockerGen to containerize software packages automatically. DockerGen constructs a knowledge graph containing rich knowledge of building Docker images by analyzing nearly 220 thousand Dockerfiles. DockerGen exploits the knowledge graph to containerize the target software by creating a Dockerfile specifying the base image, dependencies, and the operation workflow. We evaluate DockerGen on 100 software packages of various categories. DockerGen achieves a 73\% build success rate and a 59\% configuration success rate. The experimental result indicates it is viable to automate software containerization based on a domain knowledge graph.},
  keywords = {Conferences,containerization knowledge graph,Containers,dependency,Docker,Dockerfile,Image resolution,Libraries,software package,Software packages,Software systems,Writing},
  file = {/home/mechjm/Zotero/storage/4B74TLIX/Ye et al_2021_DockerGen.pdf;/home/mechjm/Zotero/storage/Q8AGGNZA/9529714.html}
}


@inproceedings{maloneyDirectnessLivenessMorphic1995,
  title = {Directness and Liveness in the Morphic User Interface Construction Environment},
  booktitle = {Proceedings of the 8th Annual {{ACM}} Symposium on {{User}} Interface and Software Technology  - {{UIST}} '95},
  author = {Maloney, John H. and Smith, Randall B.},
  year = {1995},
  pages = {21--28},
  publisher = {{ACM Press}},
  address = {{Pittsburgh, Pennsylvania, United States}},
  doi = {10.1145/215585.215636},
  isbn = {978-0-89791-709-4},
  langid = {english},
  file = {/home/mechjm/Zotero/storage/3BQD9F4N/Maloney e Smith - 1995 - Directness and liveness in the morphic user interf.pdf}
}