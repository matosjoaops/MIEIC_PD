\chapter{Repairing and Generating Dockerfiles (title is WIP)} \label{chap:sota}

Now that we've introduced the problem this thesis revolves around it's time to go over the state of the art.
This section covers existing literature and tools that are related to several components of the Dockerfile development experience and Docker in general.

\todo{Estes parágrafos deviam sobretudo fazer uma introdução ao capítulo, e ligação com o capítulo anterior. Listar as subsecções e dizer o que elas contêem não tem muito interesse, estas secções podem é explicar melhor de que forma é que as várias secções se relacionam. Mesmo assim, neste caso, como são muitas, fica um pouco maçudo, e acho que não acrescenta muito para o leitor.}

\section{Background} \label{sec:background}
...

\section{Goals and methodology} \label{sec:goals_and_methodology}

Our end goal is to help developers write Dockerfiles. To do this, we first need to know what challenges they face when writing Dockerfiles and how the quality of the Dockerfiles is affected by these challenges. Furthermore, we need to analyze current solutions that address these issues in order to build upon them. With this in mind, we came up with the following research questions:

\begin{itemize}
    \item \textbf{RQ1}: What are the challenges that developers face in the development of Dockerfiles?
    \item \textbf{RQ2}: How have these challenges been addressed so far?
\end{itemize}

To answer these questions we tried to find as much information as possible about Docker and Dockerfiles. Furthermore, we also tried to find works that analyzed a developer's subjective experience when performing development tasks. We ended up using the following queries to look for information in Google Scholar \footnote{Google Scholar, \url{https://scholar.google.com/}}:

\begin{itemize}
    \item dockerfile generation
    \item distroless
    \item docker build
    \item dockerfile
    \item dockerfile creation
    \item dockerfile generator
    \item dockerfile repair
    \item docker repair
    \item dockerfile readability
    \item dockerfile evaluation
    \item dockerfile analysis
    \item docker bloat
    \item docker build time
    \item dockerfile practices
    \item programming experience
\end{itemize}

These queries gave us plenty of results, which had to be filtered to reach an amount that could be reasonably analyzed in the amount of time that we were given. We focused on works from the last few years that focused (at least partially) on Docker or Dockerfiles (instead of merely using Docker as a tool due to its convenience). We looked at the title and abstracts of the results to perform our selection and ended up with around 50 works to analyze. Most of these were analyzed, although some had to be excluded due to either time constraints or difficulty accessing the work. 

\section{Challenges in the Development of Dockerfiles} \label{sec:challenges_development_dockerfiles}

After looking at the literature, we identified several aspects of the Dockerfile development experience that could be considered challenging. This includes the following aspects:

\begin{itemize}
    \item The amount of time required to build an image from a Dockerfile
    \item The amount of vulnerabilities present in Dockerfiles (and the corresponding images)
    \item The amount of bloat present in Docker images
    \item The reliance on trial and error to test Dockerfiles
    \item The amount of smells contained in Dockerfiles
    \item The amount of Dockerfiles that do not follow best practices
\end{itemize}

With these issues in mind, this chapter contains sections that address each of these problems. Additionally, there are also sections dedicated to repairing and generating Dockerfiles since those are features that our tool will provide and could improve the Dockerfile development experience.

\todo{Sugiro que incluas aqui um pouco sobre os objetivos desta revisão de literatura. As RQs da revisão de literatura apareceriam aqui. Além dessas perguntas, fala também um pouco do processo que seguiste para lhes tentar dar resposta, incluindo onde pesquisaste, que queries usaste, quais foram os teus critérios de inclusão/exclusão de resultados, etc.}

\todo{Sobre as secções que se seguem: cada uma delas endereça um "challenge" diferente no desenvolvimento de dockerfiles, certo? Antes de falares de cada um deste tópicos seria bom ficar mais claro de onde/porque é que aqui aparecem. Talvez a melhor abordagem seja incluires uma nova secção antes das que vêm a seguir, chamada "Challenges in the development of Dockerfiles", ou algo semelhante, que olhe para a literatura e identifique o top dos challenges mais relevantes.}

\section{Speeding up Docker builds} \label{sec:speeding_up_docker_builds}

Building Docker images can take a considerable amount of time, especially when a large amount of files have to be fetched from the internet \cite{harterSlackerFastDistribution}. Therefore, we looked for approaches to reduce the amount of time consumed by this activity. Our findings are summarized in Table \ref{tab:works_speeding_up}.

\todo{ways -> approaches}

\todo{Dependendo do que disseres acima sobre quais foram as queries que usaste, pode não fazer sentido aqui dizeres que procuraste especificamente por abordagens de aceleração do build. A ver...}

\todo{A não ser que já o tenhas dito antes (a secção de "Goals ..." acima pode ser um sítio melhor até!) era importante começar esta secção explicando qual é o interesse/importância/relevância para o teu trabalho em fazer esta análise.}

\begin{table}[H]
    \centering
    \begin{tabular}{|p{0.17\textwidth}|p{0.1\textwidth}|p{0.13\textwidth}|p{0.1\textwidth}|p{0.1\textwidth}|p{0.1\textwidth}|p{0.1\textwidth}|}
        \hline \textbf{Name} & \textbf{Speedup} & \textbf{Limitations} & \textbf{Interferes with normal Docker procedures?} & \textbf{Lines of code} & \textbf{Language used} & \textbf{Is the source code available?} \\
        \hline A Code Injection Method for Rapid Docker Image Building \cite{wangCodeInjectionMethod2019} & Up to 100000x faster & Can only be used with interpreted languages, limited to modifications in the source code & Yes & Unknown & Unknown & No \\
        \hline FastBuild: Accelerating Docker Image Building for Efficient Development and Deployment of Container \cite{huangFastBuildAcceleratingDocker2019} & Up to 10x faster & Limited to network activity & Yes & ~2600 & Go & No \\
        \hline Slacker: Fast Distribution with Lazy Docker Containers \cite{harterSlackerFastDistribution} & Up to 20x faster & Limited to network activity & Yes & Unknown & Unknown & No \\
        \hline Docker Buildx \footnotemark{} & Unknown & Unknown & No & Unknown & Go & Yes \\
        \hline
    \end{tabular}
    \caption{Works about speeding up Docker builds}
    \label{tab:works_speeding_up}
\end{table}

\footnotetext{Docker Buildx, \url{https://docs.docker.com/engine/reference/commandline/buildx/}}

\todo{Na tabela tens uma coluna sobre complexidade de implementação que é muito subjetiva. Melhor do que isso seria usares colunas com coisas objetivas mas que te permitam  concluir sobre a complexidade no texto que acompanha a tabela.}

Wang et al. \cite{wangCodeInjectionMethod2019} propose a technique that bypasses typical building procedures by injecting the code modifications directly in an image. The results are very promising. However, due to the nature of approach, it can only be used with interpreted languages and will not accelerate builds related to modifications in development artifacts that are not source code.

Huang et al. \cite{huangFastBuildAcceleratingDocker2019} and Harter et al. \cite{harterSlackerFastDistribution} address the network bottleneck in different ways. The former caches files locally and intercepts Docker's network requests in order to serve files that have been stored locally. The latter proposes a new storage driver that lazily fetches files from the network. Both show promising results and do not address other inefficiencies in the Docker building process. FastBuild was implemented using around 2600 lines of Go code.

The works described so far interfere with the normal Docker build procedures and do not have public source code for their tools. This makes them harder to implement. Another solution is offered by the Docker development team, Buildx. Buildx makes use of a newer backend, BuildKit \footnote{Docker BuildKit, \url{https://docs.docker.com/build/buildkit/}}, which brings many features that can potentially accelerate docker builds. However, to our knowledge, an apples to apples time comparison has not been made. Implementing this in Dockerlive wouldn't be very hard but because the output of the buildx command is different, some modifications would still be required.

\section{Dockerfile Generation} \label{sec:dockerfile_generation}

Many projects out there contain Dockerfiles that can not even be used to build an image \cite{wuEmpiricalStudyBuild2020,liDockerMockPreBuildDetection2021}. Therefore, having a way to generate a functinoal Dockerfile for a given project can be very useful. In this section, we looked for works that showcased ways to accomplish this. Our findings are summarized in Table \ref{tab:works_dockerfile_generation}.

\todo{No parágrafo anterior, "easy" não parece ser o melhor adjetivo --- fácil comparaticamente com quê? No artigo que citas estávamos interessados sobretudo em aferir quão mais trabalhosas eram umas atividades \textbf{comparaticamente com outras}. Este "easy" não tem uma base de comparação tão clara.}

\todo{As duas primeiras frases que aqui tens estão a servir essencialmente para motivar a importancia do que vais falar nesta secção. Algo que pode ajudar mais a fazer isso é definires bem os objetivos de todo este capítulo (com as perguntas, secção sobre os challenges, etc. Ver o que escrevi acima).}

\begin{table}[H]
    \centering
    \begin{tabular}{|p{0.4\textwidth}|p{0.2\textwidth}|p{0.3\textwidth}|}
        \hline \textbf{Name} & \textbf{Successful generation rate} & \textbf{Limitations} \\
        \hline Applying Model-Driven Engineering to Stimulate the Adoption of DevOps Processes in Small and Medium-Sized Development Organizations \cite{sorgallaApplyingModelDrivenEngineering2021} & Unknown & An Open API Spec is required \\
        \hline Burner: Recipe Automatic Generation for HPC Container Based on Domain Knowledge Graph \cite{zhongBurnerRecipeAutomatic2022} & Up to 80\% & A vast knowledge graph (2832 nodes and 62614 edges) is required, focused on Singularity \\
        \hline Container-Based Module Isolation for Cloud Services \cite{kehrerContainerBasedModuleIsolation2019} & Unknown & Requires the use of templates to generate the files \\
        \hline DockerGen: A Knowledge Graph based Approach for Software Containerization \cite{yeDockerGenKnowledgeGraph2021} & Up to 73\% & A vast knowledge graph (900000 nodes and 2900000 edges) is required \\
        \hline DockerizeMe: Automatic Inference of Environment Dependencies for Python Code Snippets \cite{hortonDockerizeMeAutomaticInference2019} & Up to 30\% & Limited to Python snippets, requires a knowledge base \\
        \hline ExploitWP2Docker: a Platform for Automating the Generation of Vulnerable WordPress Environments for Cyber Ranges \cite{caturanoExploitWP2DockerPlatformAutomating2022} & Up to 39\% & Limited to security testing scenarios, requires an exploit description \\
        \hline MAKING CONTAINERS EASIER WITH HPC CONTAINER MAKER \cite{mcmillanMAKINGCONTAINERSEASIER} & Unknown & Requires Python code to generate the files \\
        \hline
    \end{tabular}
    \caption{Works about generating Dockerfiles}
    \label{tab:works_dockerfile_generation}
\end{table}

\todo{Se a memória não me falha, o DockerizeMe só fuciona para snippets, e não para um sistema completo.}

\todo{A coluna sobre a complexidade é um pouco subjetiva...}

Zhong et al. \cite{zhongBurnerRecipeAutomatic2022}, Ye et al. \cite{yeDockerGenKnowledgeGraph2021} and Horton et al. \cite{hortonDockerizeMeAutomaticInference2019} present solutions that require pre-existing knowledge bases in order to generate the files, making them hard to implement in a project like ours, which is not completely focused on file generation. DockerizeMe is also limited to Python environments, while Burner is more focused on Singularity \footnote{Singularity, \url{https://apptainer.org/}}, a containerization tool similar to Docker but focused on HPC (High Performance Computing).



Caturano et al. \cite{caturanoExploitWP2DockerPlatformAutomating2022} propose a tool that uses Docker to generate security testing environments from exploit descriptions. Sorgalla et al. \cite{sorgallaApplyingModelDrivenEngineering2021}'s work can generate Dockerfiles from models, which are generated from Open API Specifications (like Swagger \footnote{Swagger, \url{https://swagger.io/}}). Kehrer et al. \cite{kehrerContainerBasedModuleIsolation2019} use Apache FreeMarker \footnote{Apache FreeMarker, \url{https://freemarker.apache.org/}} to generate Dockerfiles from templates. McMillan et al. \cite{mcmillanMAKINGCONTAINERSEASIER} offer a tool that allows developer to use Python code to define the information required to generate Dockerfiles.

All these works show varying degrees of success and some of them are not even focused on the Dockerfile generation aspect.

\section{Dockerfile Smells} \label{sec:dockerfile_smells}

Smells are commonly found in Dockerfiles \cite{wuCharacterizingOccurrenceDockerfile2020}, making it important to create ways of detecting and, if possible, remove them. This section covers works related to this. Table \ref{tab:dockerfile_smells} contains a list of smells found in literature.

\begin{table}[H]
    \centering
    \begin{tabular}{|p{0.2\textwidth}|p{0.2\textwidth}|p{0.5\textwidth}|}
        \hline \textbf{Smell} & \textbf{Related works} & \textbf{Related findings} \\
        \hline Temporary File & \cite{luEmpiricalCaseStudy2019} and \cite{xuDockerfileTFSmell2019} & The smell is quite common and can be divided into 4 different types; can be detected through static and dynamic analysis \\
        \hline SATD & \cite{azumaEmpiricalStudySelfadmitted2022} & This type of smell appears in Dockerfiles and can be divided into several classes and subclasses \\
        \hline Lack of version tagging/pinning & \cite{wuCharacterizingOccurrenceDockerfile2020} & N/A \\
        \hline Use of the MAINTAINER instruction & \cite{wuCharacterizingOccurrenceDockerfile2020} & N/A \\
        \hline Use of \textit{cd} to switch directories instead of WORKDIR & \cite{wuCharacterizingOccurrenceDockerfile2020} & N/A \\
        \hline The parameter \textit{--no-install-recommends} is not used when installing packages with APT & \cite{wuCharacterizingOccurrenceDockerfile2020} & N/A \\
        \hline
    \end{tabular}
    \caption{Dockerfile smells}
    \label{tab:dockerfile_smells}
\end{table}

\todo{Mais do que listar/caracterizar artigos, idealmente estas tabelas seriam sobre as coisas que te interessam encontrar. Por exemplo, nesta secção estás interessado é nos smells, logo, acho que faria mais sentido ser uma tabela de smells, em que indicavas o artigo em que o encontraste (em vez de uma tabela de artigos em que indicas os smells, estou a fazer sentido?). A mesma ideia é aplicável às outras secções.}

Lu et al. \cite{luEmpiricalCaseStudy2019} and Xu et al. \cite{xuDockerfileTFSmell2019} have focused on the temporary file smell and propose ways to detect this smell. A repair to deal with this smell could be implemented using the information provided by these works.

Azuma et al. \cite{azumaEmpiricalStudySelfadmitted2022} focus on a variation of smells they call SATD (self-admitted technical debt) which can be detected in comments written in the Dockerfiles. Due to the nature of these SATDs, implementing repairs to eliminate them could be very complicated.

Wu et al. \cite{wuCharacterizingOccurrenceDockerfile2020} analyzed a large amount of open-source projects and found that Dockerfile smells are very common and their frequency changes according to several factors like the programming language used by the project or the project's age. Due to the variety of smells covered by this study implementing repairs to deal with all of them would be difficult. For the same reasons, only some of the analyzed smells were listed here.

\section{Dockerfile Good Practices} \label{sec:dockerfile_good_practices}

To prevent the creation of smells like the ones mentioned in Section \ref{sec:dockerfile_smells}, a developer should follow good practices. This section goes over works that cover these practices. Table \ref{tab:dockerfile_good_practices} contains a list of good practices found in literature.

\begin{table}[H]
    \centering
    \begin{tabular}{|p{0.7\textwidth}|p{0.2\textwidth}|}
        \hline \textbf{Practice} & \textbf{Related works} \\
        \hline Format for clarity & \cite{nustTenSimpleRules2020} \\
        \hline Document within the Dockerfile & \cite{nustTenSimpleRules2020} \\
        \hline Specify software versions & \cite{nustTenSimpleRules2020} \\
        \hline Order the instructions & \cite{nustTenSimpleRules2020} \\
        \hline Run the container in rootless mode & \cite{prinettoSecurityMisconfigurationsDetection} \\
        \hline Use tagged minimal images and multistage builds & \cite{prinettoSecurityMisconfigurationsDetection} \\
        \hline Use COPY with specific parameters & \cite{prinettoSecurityMisconfigurationsDetection} \\
        \hline Update and install packages in the same RUN instruction & \cite{prinettoSecurityMisconfigurationsDetection} \\
        \hline Use COPY instead of ADD & \cite{prinettoSecurityMisconfigurationsDetection} \\
        \hline Do not leak sensitive information to an image & \cite{prinettoSecurityMisconfigurationsDetection} \\
        \hline Remove unnecessary dependencies & \cite{prinettoSecurityMisconfigurationsDetection} \\
        \hline Only expose ports that are needed & \cite{prinettoSecurityMisconfigurationsDetection} \\
        \hline Use official images when possible & \cite{prinettoSecurityMisconfigurationsDetection} \\
        \hline Remove temporary directories & \cite{henkelLearningUnderstandingSupporting2020} \\
        \hline Use flag \textit{-f} with curl & \cite{henkelLearningUnderstandingSupporting2020} \\
        \hline Remove tarballs after extraction & \cite{henkelLearningUnderstandingSupporting2020} \\
        \hline Do not use APK's cache & \cite{henkelLearningUnderstandingSupporting2020} \\
        \hline Do not install dependencies recommended by APT & \cite{henkelLearningUnderstandingSupporting2020} \\
        \hline Use HTTPS urls with curl & \cite{henkelLearningUnderstandingSupporting2020} \\
        \hline Use batch flag with gpg & \cite{henkelLearningUnderstandingSupporting2020} \\
        \hline Use HTTPS urls with wget & \cite{henkelLearningUnderstandingSupporting2020} \\
        \hline Use flag \textit{-y} with \textit{apt-get install} & \cite{henkelLearningUnderstandingSupporting2020} \\
        \hline Remove APT lists after package installation & \cite{henkelLearningUnderstandingSupporting2020} \\
        \hline Run \textit{apt-get update} before \textit{apt-get install} & \cite{henkelLearningUnderstandingSupporting2020} \\
        \hline
    \end{tabular}
    \caption{Dockerfile good practices}
    \label{tab:dockerfile_good_practices}
\end{table}

Henkel et al. \cite{henkelLearningUnderstandingSupporting2020} mined rules from Dockerfiles created by experts, allowing them to create a set of "gold rules", a set of patterns that often appear in Dockerfiles written by these experts. Some of these "gold rules" are not listed above because it's not clear what they refer to. It should be possible to implement the listed ones as repairs.

Prinetto et al. \cite{prinettoSecurityMisconfigurationsDetection} looked for flaws in Dockerfiles that could lead to vulnerabilities in a system. As part of that work they list a set of practices developers should follow to improve a Docker image's security. Most of the practices listed could be implemented as repair, although some of them would be too complex to implement.

Nust et al. \cite{nustTenSimpleRules2020} propose a list of 10 rules developers should follow when writing Dockerfiles for data science environments. Some of these rules are applicable to other scenarios and 2 of those could be implemented as repairs.

\section{Dockerfile Security} \label{sec:dockerfile_security}

Nowadays, security is a topic that is heavily discussed and deserves a great amount of attention from developers. However, security problems are still commonly found in Dockerfiles \cite{doanDAVSDockerfileAnalysis2022} and many developers do not have the knowledge required to evaluate how vulnerable their containers are \cite{zareiInvestigatingInnerWorkings2022}. For these reasons, it's important to study Docker containers from a security perspective, which is what this section focuses on. Our findings are summarized in Table \ref{tab:works_dockerfile_security}.

\begin{table}[H]
    \centering
    \begin{tabular}{|p{0.27\textwidth}|p{0.3\textwidth}|p{0.3\textwidth}|}
        \hline \textbf{Name} & \textbf{Findings} & \textbf{Implementation notes} \\
        \hline DAVS: Dockerfile Analysis for Container Image Vulnerability Scanning \cite{doanDAVSDockerfileAnalysis2022} & DAVS can detect more vulnerabilities than competing scanners & It should be possible to repair some of the mentioned vulnerabilities, although it would be easier to use existing scanners \\
        \hline Investigating the inner workings of container image vulnerability scanners \cite{zareiInvestigatingInnerWorkings2022} & Many scanners use the same methods to detect vulnerabilities, which have limitations & Using one of these scanners could be useful \\
        \hline Outdated software in container images \cite{linnalampiOutdatedSoftwareContainer2021} & Having outdated software in containers brings security problems and there are limitations to what current scanners can detect, new detection method is proposed & It should be possible to implement some repair to try to address this situation \\
        \hline Security Analysis of Code Bloat in Machine Learning Systems \cite{ahmedSecurityAnalysisCode2022} & Removing bloat from containers used in machine learning environments can considerably improve security & It should be possible to implement some repairs that reduce bloat \\
        \hline Security Misconfigurations Detection and Repair in Dockerfile \cite{prinettoSecurityMisconfigurationsDetection} & Security problems are common in containers, a way to repair them is proposed & It might be possible to implement the proposed technique to repair the problems \\
        \hline
    \end{tabular}
    \caption{Works about Dockerfile security}
    \label{tab:works_dockerfile_security}
\end{table}

Doan et al. \cite{doanDAVSDockerfileAnalysis2022} propose DAVS (Dockerfile analysis-based vulnerability scanning), a tool that can detect potentially vulnerable files in containers. This approach allows them to detect more vulnerabilities than current scanners, which, according to Zarei et al. \cite{zareiInvestigatingInnerWorkings2022}, rely on information provided by distribution package managers. This information can be manipulated and, in some cases, may not even be available, which prevents scanners from detecting vulnerabilities.

Ahmed et al. \cite{ahmedSecurityAnalysisCode2022} used Cimplifier \cite{rastogiCimplifierAutomaticallyDebloating2017} to debloat containers used in machine learning environments and found the amount of vulnerabilities present in those containers was significantly reduced.

Linnalampi et al. \cite{linnalampiOutdatedSoftwareContainer2021} found that having outdated software introduces vulnerabilities in containers and propose a new method to detect vulnerabilities by analyzing the binaries present in containers to detect the software versions that are in use. This approach would address some of the limitations of current scanning techniques.

Prinetto et al. \cite{prinettoSecurityMisconfigurationsDetection} found that security problems are common and propose a way to repair them by processing the Dockerfile to obtain the abstract syntax tree, find the vulnerabilities and modify the tree before reconverting into a file that is no longer vulnerable.

Implementing repairs that address most of the problems and vulnerabilities found by these works should be possible. It may even be possible to use some of the proposed approaches.

\section{Dockerfile Repair} \label{sec:dockerfile_repair}

Like the previous sections have shown, the average Dockerfile has several problems and it can be difficult for a developer to figure out how to deal with those issues in an optimal way. This makes it important to create tools that can assist developers in the repair process. This section goes over works that do that (although other sections also discuss works that perform repairs that are related to more specific scenarios). Table \ref{tab:dockerfile_repair} contains a list of repairs found in literature.

\begin{table}[H]
    \centering
    \begin{tabular}{|p{0.7\textwidth}|p{0.2\textwidth}|}
        \hline \textbf{Repair} & \textbf{Related works} \\
        \hline Base image update & \cite{kitajimaLatestImageRecommendation2020} \\
        \hline Gold rule enforcement (rules listed in Section \ref{sec:dockerfile_good_practices}) & \cite{henkelLearningUnderstandingSupporting2020} \\
        \hline Update portions of the Dockerfile which are ties to values in source code & \cite{hassanRUDSEARecommendingUpdates2018} \\
        \hline Combine consecutive RUN instructions into one & \cite{benniSupportingMicroservicesDeployment2018} \\
        \hline Fix Ruby version error by pinning Ruby base image version & \cite{henkelShipwrightHumanintheLoopSystem2021} \\
        \hline Fix RPM installation error by installing a plugin first & \cite{henkelShipwrightHumanintheLoopSystem2021} \\
        \hline Update to the latest base image release & \cite{henkelShipwrightHumanintheLoopSystem2021} \\
        \hline Install libpng-dev instead of libpng12-dev & \cite{henkelShipwrightHumanintheLoopSystem2021} \\
        \hline Fix "Unable to locate package" by downgrading Ubuntu base image version & \cite{henkelShipwrightHumanintheLoopSystem2021} \\
        \hline Fix Gemfile version error by pinning Rucy base image version & \cite{henkelShipwrightHumanintheLoopSystem2021} \\
        \hline Fix Ruby encoding error by setting environment variable & \cite{henkelShipwrightHumanintheLoopSystem2021} \\
        \hline Install missing packages using APK or APT without using cached data & \cite{henkelShipwrightHumanintheLoopSystem2021} \\
        \hline Do not install the bzr package with APK & \cite{henkelShipwrightHumanintheLoopSystem2021} \\
        \hline Add the \textit{-L} flag when using curl to install conda & \cite{henkelShipwrightHumanintheLoopSystem2021} \\
        \hline
    \end{tabular}
    \caption{Dockerfile repairs}
    \label{tab:dockerfile_repair}
\end{table}

Kitajima et al. \cite{kitajimaLatestImageRecommendation2020} focused on updating a container's base image by analyzing the available tags, while Hassan et al. \cite{hassanRUDSEARecommendingUpdates2018} focused on portions of the Dockerfile which are tied to values in the source code.

Henkel et al. \cite{henkelLearningUnderstandingSupporting2020} offers a way to detect violations of the gold rules they obtained but don't automate the repair of said violations. Henkel et al. \cite{henkelShipwrightHumanintheLoopSystem2021} also proposes a different approach for automating repairs, although most of the repairs listed here are specific to certain programming languages or package managers.

Benni et al. \cite{benniSupportingMicroservicesDeployment2018} describe a way to reduce the number of layers in Dockerfiles in order to take advantage of layer caching.

Implementing the repairs mentioned in this section should be possible, although these implementations would have varying degrees of complexity.

\section{Dockerfile Bloat} \label{sec:dockerfile_bloat}
\section{Dockerfile Testing} \label{sec:dockerfile_testing}
\section{General Discussion} \label{sec:general_discussion}

Ksontini et al. \cite{ksontiniRefactoringsTechnicalDebt} focused on refactorings (a concept which is closely tied to smells) and found that developers' main motivations for performing refactorings were tied to maintainability and image size among others. Implementing some of these refactorings as repairs would be useful, although implementing all of them would be challenging.

\todo{Seria aqui um bom sítio onde responder de forma mais explícita às perguntas que colocamos no início do capítulo.}